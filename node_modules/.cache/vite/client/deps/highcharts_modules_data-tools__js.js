import {
  __commonJS
} from "./chunk-V4OQ3NZ2.js";

// node_modules/highcharts/modules/data-tools.js
var require_data_tools = __commonJS({
  "node_modules/highcharts/modules/data-tools.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.6 (2024-07-08)
    *
    * Highcharts
    *
    * (c) 2010-2024 Highsoft AS
    *
    * License: www.highcharts.com/license
    */
    function(e) {
      "object" == typeof module && module.exports ? (e.default = e, module.exports = e) : "function" == typeof define && define.amd ? define("highcharts/modules/data-tools", ["highcharts"], function(t) {
        return e(t), e.Highcharts = t, e;
      }) : e("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(e) {
      "use strict";
      var t = e ? e._modules : {};
      function s(t2, s2, r, o) {
        t2.hasOwnProperty(s2) || (t2[s2] = o.apply(null, r), "function" == typeof CustomEvent && e.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: s2, module: t2[s2] } })));
      }
      s(t, "Data/Modifiers/DataModifier.js", [t["Core/Utilities.js"]], function(e2) {
        var t2;
        let { addEvent: s2, fireEvent: r, merge: o } = e2;
        class n {
          benchmark(e3, t3) {
            let s3 = [], r2 = this, n2 = () => {
              r2.modifyTable(e3), r2.emit({ type: "afterBenchmarkIteration" });
            }, { iterations: i } = o({ iterations: 1 }, t3);
            r2.on("afterBenchmarkIteration", () => {
              if (s3.length === i) {
                r2.emit({ type: "afterBenchmark", results: s3 });
                return;
              }
              n2();
            });
            let l = { startTime: 0, endTime: 0 };
            return r2.on("modify", () => {
              l.startTime = window.performance.now();
            }), r2.on("afterModify", () => {
              l.endTime = window.performance.now(), s3.push(l.endTime - l.startTime);
            }), n2(), s3;
          }
          emit(e3) {
            r(this, e3.type, e3);
          }
          modify(e3, t3) {
            let s3 = this;
            return new Promise((r2, o2) => {
              e3.modified === e3 && (e3.modified = e3.clone(false, t3));
              try {
                r2(s3.modifyTable(e3, t3));
              } catch (r3) {
                s3.emit({ type: "error", detail: t3, table: e3 }), o2(r3);
              }
            });
          }
          modifyCell(e3, t3, s3, r2, o2) {
            return this.modifyTable(e3);
          }
          modifyColumns(e3, t3, s3, r2) {
            return this.modifyTable(e3);
          }
          modifyRows(e3, t3, s3, r2) {
            return this.modifyTable(e3);
          }
          on(e3, t3) {
            return s2(this, e3, t3);
          }
        }
        return (t2 = n || (n = {})).types = {}, t2.registerType = function(e3, s3) {
          return !!e3 && !t2.types[e3] && !!(t2.types[e3] = s3);
        }, n;
      }), s(t, "Data/DataTable.js", [t["Core/Utilities.js"]], function(e2) {
        let { addEvent: t2, fireEvent: s2, uniqueKey: r } = e2;
        class o {
          static isNull(e3) {
            if (e3 === o.NULL) return true;
            if (e3 instanceof Array) {
              if (!e3.length) return false;
              for (let t3 = 0, s3 = e3.length; t3 < s3; ++t3) if (null !== e3[t3]) return false;
            } else {
              let t3 = Object.keys(e3);
              if (!t3.length) return false;
              for (let s3 = 0, r2 = t3.length; s3 < r2; ++s3) if (null !== e3[t3[s3]]) return false;
            }
            return true;
          }
          constructor(e3 = {}) {
            this.aliases = e3.aliases ? JSON.parse(JSON.stringify(e3.aliases)) : {}, this.autoId = !e3.id, this.columns = {}, this.id = e3.id || r(), this.modified = this, this.rowCount = 0, this.versionTag = r(), this.rowKeysId = e3.rowKeysId;
            let t3 = e3.columns || {}, s3 = Object.keys(t3), o2 = this.columns, n = 0;
            for (let e4 = 0, r2 = s3.length, i2, l2; e4 < r2; ++e4) i2 = t3[l2 = s3[e4]].slice(), o2[l2] = i2, n = Math.max(n, i2.length);
            for (let e4 = 0, t4 = s3.length; e4 < t4; ++e4) o2[s3[e4]].length = n;
            this.rowCount = n;
            let i = e3.aliases || {}, l = Object.keys(i), a = this.aliases;
            for (let e4 = 0, t4 = l.length, s4; e4 < t4; ++e4) a[s4 = l[e4]] = i[s4];
            this.setRowKeysColumn(n);
          }
          clone(e3, t3) {
            let s3 = {};
            this.emit({ type: "cloneTable", detail: t3 }), e3 || (s3.aliases = this.aliases, s3.columns = this.columns), this.autoId || (s3.id = this.id), this.rowKeysId && (s3.rowKeysId = this.rowKeysId);
            let r2 = new o(s3);
            return e3 || (r2.versionTag = this.versionTag), this.emit({ type: "afterCloneTable", detail: t3, tableClone: r2 }), r2;
          }
          deleteColumnAlias(e3) {
            let t3 = this.aliases[e3], s3 = this.modifier;
            return t3 && (delete this.aliases[e3], s3 && s3.modifyColumns(this, { [t3]: Array(this.rowCount) }, 0)), t3;
          }
          deleteColumns(e3, t3) {
            let s3 = this.columns, r2 = {}, o2 = {}, n = this.modifier, i = this.rowCount;
            if ((e3 = e3 || Object.keys(s3)).length) {
              this.emit({ type: "deleteColumns", columnNames: e3, detail: t3 });
              for (let t4 = 0, n2 = e3.length, l2, a; t4 < n2; ++t4) (l2 = s3[a = e3[t4]]) && (r2[a] = l2, o2[a] = Array(i)), delete s3[a];
              let l = Object.keys(s3).length;
              return this.rowKeysId && 1 === l && (delete s3[this.rowKeysId], l = 0), l || (this.rowCount = 0), n && n.modifyColumns(this, o2, 0, t3), this.emit({ type: "afterDeleteColumns", columns: r2, columnNames: e3, detail: t3 }), r2;
            }
          }
          deleteRows(e3, t3 = 1, s3) {
            let r2 = [], o2 = [], n = this.modifier;
            if (this.emit({ type: "deleteRows", detail: s3, rowCount: t3, rowIndex: e3 || 0 }), void 0 === e3 && (e3 = 0, t3 = this.rowCount), t3 > 0 && e3 < this.rowCount) {
              let s4 = this.columns, n2 = Object.keys(s4);
              for (let i = 0, l = n2.length, a, u; i < l; ++i) {
                u = (a = s4[n2[i]]).splice(e3, t3), i || (this.rowCount = a.length);
                for (let e4 = 0, t4 = u.length; e4 < t4; ++e4) r2[e4] = r2[e4] || [], r2[e4][i] = u[e4];
                o2.push(Array(l));
              }
            }
            return n && n.modifyRows(this, o2, e3 || 0, s3), this.emit({ type: "afterDeleteRows", detail: s3, rowCount: t3, rowIndex: e3 || 0, rows: r2 }), r2;
          }
          emit(e3) {
            switch (e3.type) {
              case "afterDeleteColumns":
              case "afterDeleteRows":
              case "afterSetCell":
              case "afterSetColumns":
              case "afterSetRows":
                this.versionTag = r();
            }
            s2(this, e3.type, e3);
          }
          getCell(e3, t3) {
            e3 = this.aliases[e3] || e3;
            let s3 = this.columns[e3];
            if (s3) return s3[t3];
          }
          getCellAsBoolean(e3, t3) {
            e3 = this.aliases[e3] || e3;
            let s3 = this.columns[e3];
            return !!(s3 && s3[t3]);
          }
          getCellAsNumber(e3, t3, s3) {
            e3 = this.aliases[e3] || e3;
            let r2 = this.columns[e3], o2 = r2 && r2[t3];
            switch (typeof o2) {
              case "boolean":
                return o2 ? 1 : 0;
              case "number":
                return isNaN(o2) && !s3 ? null : o2;
            }
            return isNaN(o2 = parseFloat(`${o2 ?? ""}`)) && !s3 ? null : o2;
          }
          getCellAsString(e3, t3) {
            e3 = this.aliases[e3] || e3;
            let s3 = this.columns[e3];
            return `${s3 && s3[t3]}`;
          }
          getColumn(e3, t3) {
            return this.getColumns([e3], t3)[e3];
          }
          getColumnAsNumbers(e3, t3) {
            let s3 = this.columns[e3 = this.aliases[e3] || e3], r2 = [];
            if (s3) {
              let o2 = s3.length;
              if (t3) for (let t4 = 0; t4 < o2; ++t4) r2.push(this.getCellAsNumber(e3, t4, true));
              else {
                for (let e4 = 0, t4; e4 < o2; ++e4) {
                  if ("number" == typeof (t4 = s3[e4])) return s3.slice();
                  if (null != t4) break;
                }
                for (let t4 = 0; t4 < o2; ++t4) r2.push(this.getCellAsNumber(e3, t4));
              }
            }
            return r2;
          }
          getColumnNames() {
            let e3 = Object.keys(this.columns);
            return this.removeRowKeysColumn(e3), e3;
          }
          getColumns(e3, t3) {
            let s3 = this.aliases, r2 = this.columns, o2 = {};
            e3 = e3 || Object.keys(r2), this.removeRowKeysColumn(e3);
            for (let n = 0, i = e3.length, l, a; n < i; ++n) (l = r2[s3[a = e3[n]] || a]) && (o2[a] = t3 ? l : l.slice());
            return o2;
          }
          getModifier() {
            return this.modifier;
          }
          getRow(e3, t3) {
            return this.getRows(e3, 1, t3)[0];
          }
          getRowCount() {
            return this.rowCount;
          }
          getRowIndexBy(e3, t3, s3) {
            e3 = this.aliases[e3] || e3;
            let r2 = this.columns[e3];
            if (r2) {
              let e4 = r2.indexOf(t3, s3);
              if (-1 !== e4) return e4;
            }
          }
          getRowObject(e3, t3) {
            return this.getRowObjects(e3, 1, t3)[0];
          }
          getRowObjects(e3 = 0, t3 = this.rowCount - e3, s3) {
            let r2 = this.aliases, o2 = this.columns, n = Array(t3);
            s3 = s3 || Object.keys(o2), this.removeRowKeysColumn(s3);
            for (let i = e3, l = 0, a = Math.min(this.rowCount, e3 + t3), u, h; i < a; ++i, ++l) for (let e4 of (h = n[l] = {}, s3)) u = o2[r2[e4] || e4], h[e4] = u ? u[i] : void 0;
            return n;
          }
          getRows(e3 = 0, t3 = this.rowCount - e3, s3) {
            let r2 = this.aliases, o2 = this.columns, n = Array(t3);
            s3 = s3 || Object.keys(o2);
            for (let i = e3, l = 0, a = Math.min(this.rowCount, e3 + t3), u, h; i < a; ++i, ++l) for (let e4 of (h = n[l] = [], s3)) u = o2[r2[e4] || e4], h.push(u ? u[i] : void 0);
            return n;
          }
          getVersionTag() {
            return this.versionTag;
          }
          hasColumns(e3) {
            let t3 = this.aliases, s3 = this.columns;
            for (let r2 = 0, o2 = e3.length, n; r2 < o2; ++r2) if (!s3[n = e3[r2]] && !t3[n]) return false;
            return true;
          }
          hasRowWith(e3, t3) {
            e3 = this.aliases[e3] || e3;
            let s3 = this.columns[e3];
            return !!s3 && -1 !== s3.indexOf(t3);
          }
          on(e3, s3) {
            return t2(this, e3, s3);
          }
          renameColumn(e3, t3) {
            let s3 = this.columns;
            if (s3[e3]) {
              if (e3 !== t3) {
                let r2 = this.aliases;
                r2[t3] && delete r2[t3], s3[t3] = s3[e3], delete s3[e3], this.rowKeysId && this.moveRowKeysColumnToLast(s3, this.rowKeysId);
              }
              return true;
            }
            return false;
          }
          setCell(e3, t3, s3, r2) {
            let o2 = this.columns, n = this.modifier, i = o2[e3 = this.aliases[e3] || e3];
            i && i[t3] === s3 || (this.emit({ type: "setCell", cellValue: s3, columnName: e3, detail: r2, rowIndex: t3 }), i || (i = o2[e3] = Array(this.rowCount)), t3 >= this.rowCount && (this.rowCount = t3 + 1), i[t3] = s3, n && n.modifyCell(this, e3, t3, s3), this.emit({ type: "afterSetCell", cellValue: s3, columnName: e3, detail: r2, rowIndex: t3 }));
          }
          setColumn(e3, t3 = [], s3 = 0, r2) {
            this.setColumns({ [e3]: t3 }, s3, r2);
          }
          setColumns(e3, t3, s3) {
            let r2 = this.columns, o2 = this.modifier, n = void 0 === t3, i = Object.keys(e3);
            this.emit({ type: "setColumns", columns: e3, columnNames: i, detail: s3, rowIndex: t3 });
            for (let s4 = 0, o3 = i.length, l2, a; s4 < o3; ++s4) if (l2 = e3[a = i[s4]], a = this.aliases[a] || a, n) r2[a] = l2.slice(), this.rowCount = l2.length;
            else {
              let e4 = r2[a] ? r2[a] : r2[a] = Array(this.rowCount);
              for (let s5 = t3 || 0, r3 = l2.length; s5 < r3; ++s5) e4[s5] = l2[s5];
              this.rowCount = Math.max(this.rowCount, e4.length);
            }
            let l = Object.keys(r2);
            for (let e4 = 0, t4 = l.length; e4 < t4; ++e4) r2[l[e4]].length = this.rowCount;
            o2 && o2.modifyColumns(this, e3, t3 || 0), this.rowKeysId && this.moveRowKeysColumnToLast(r2, this.rowKeysId), this.emit({ type: "afterSetColumns", columns: e3, columnNames: i, detail: s3, rowIndex: t3 });
          }
          setRowKeysColumn(e3) {
            let t3 = this.rowKeysId;
            if (!t3) return;
            this.columns[t3] = [];
            let s3 = this.columns[t3];
            for (let r2 = 0; r2 < e3; r2++) s3.push(t3 + "_" + r2);
          }
          getRowKeysColumn() {
            let e3 = this.rowKeysId;
            if (e3) return this.columns[e3];
          }
          getRowIndexOriginal(e3) {
            let t3 = this.rowKeysId;
            return t3 ? ("" + this.columns[t3][e3]).split("_")[1] : String(e3);
          }
          setModifier(e3, t3) {
            let s3 = this;
            return s3.emit({ type: "setModifier", detail: t3, modifier: e3, modified: s3.modified }), s3.modified = s3, s3.modifier = e3, (e3 ? e3.modify(s3) : Promise.resolve(s3)).then((s4) => (s4.emit({ type: "afterSetModifier", detail: t3, modifier: e3, modified: s4.modified }), s4)).catch((t4) => {
              throw s3.emit({ type: "setModifierError", error: t4, modifier: e3, modified: s3.modified }), t4;
            });
          }
          setRow(e3, t3, s3) {
            this.setRows([e3], t3, s3);
          }
          setRows(e3, t3 = this.rowCount, s3) {
            let r2 = this.aliases, n = this.columns, i = Object.keys(n), l = this.modifier, a = e3.length;
            this.emit({ type: "setRows", detail: s3, rowCount: a, rowIndex: t3, rows: e3 });
            for (let s4 = 0, l2 = t3, u2; s4 < a; ++s4, ++l2) if ((u2 = e3[s4]) === o.NULL) for (let e4 = 0, t4 = i.length; e4 < t4; ++e4) n[i[e4]][l2] = null;
            else if (u2 instanceof Array) for (let e4 = 0, t4 = i.length; e4 < t4; ++e4) n[i[e4]][l2] = u2[e4];
            else {
              let e4 = Object.keys(u2);
              for (let t4 = 0, s5 = e4.length, o2; t4 < s5; ++t4) n[o2 = r2[o2 = e4[t4]] || o2] || (n[o2] = Array(l2 + 1)), n[o2][l2] = u2[o2];
            }
            let u = t3 + a;
            if (u > this.rowCount) {
              this.rowCount = u;
              for (let e4 = 0, t4 = i.length; e4 < t4; ++e4) n[i[e4]].length = u;
            }
            this.rowKeysId && !i.includes(this.rowKeysId) && this.setRowKeysColumn(a), l && l.modifyRows(this, e3, t3), this.emit({ type: "afterSetRows", detail: s3, rowCount: a, rowIndex: t3, rows: e3 });
          }
          moveRowKeysColumnToLast(e3, t3) {
            let s3 = e3[t3];
            delete e3[t3], e3[t3] = s3;
          }
          removeRowKeysColumn(e3) {
            this.rowKeysId && -1 !== e3.indexOf(this.rowKeysId) && e3.pop();
          }
        }
        return o.NULL = {}, o.version = "1.0.0", o;
      }), s(t, "Data/Connectors/DataConnector.js", [t["Data/Modifiers/DataModifier.js"], t["Data/DataTable.js"], t["Core/Utilities.js"]], function(e2, t2, s2) {
        var r;
        let { addEvent: o, fireEvent: n, merge: i, pick: l } = s2;
        class a {
          constructor(e3 = {}) {
            this.table = new t2(e3.dataTable), this.metadata = e3.metadata || { columns: {} };
          }
          get polling() {
            return !!this.polling;
          }
          describeColumn(e3, t3) {
            let s3 = this.metadata.columns;
            s3[e3] = i(s3[e3] || {}, t3);
          }
          describeColumns(e3) {
            let t3;
            let s3 = Object.keys(e3);
            for (; "string" == typeof (t3 = s3.pop()); ) this.describeColumn(t3, e3[t3]);
          }
          emit(e3) {
            n(this, e3.type, e3);
          }
          getColumnOrder(e3) {
            let t3 = this.metadata.columns, s3 = Object.keys(t3 || {});
            if (s3.length) return s3.sort((e4, s4) => l(t3[e4].index, 0) - l(t3[s4].index, 0));
          }
          getSortedColumns(e3) {
            return this.table.getColumns(this.getColumnOrder(e3));
          }
          load() {
            return n(this, "afterLoad", { table: this.table }), Promise.resolve(this);
          }
          on(e3, t3) {
            return o(this, e3, t3);
          }
          save() {
            return n(this, "saveError", { table: this.table }), Promise.reject(Error("Not implemented"));
          }
          setColumnOrder(e3) {
            for (let t3 = 0, s3 = e3.length; t3 < s3; ++t3) this.describeColumn(e3[t3], { index: t3 });
          }
          setModifierOptions(t3) {
            let s3 = t3 && e2.types[t3.type];
            return this.table.setModifier(s3 ? new s3(t3) : void 0).then(() => this);
          }
          startPolling(e3 = 1e3) {
            let t3 = this;
            window.clearTimeout(t3._polling), t3._polling = window.setTimeout(() => t3.load().catch((e4) => t3.emit({ type: "loadError", error: e4, table: t3.table })).then(() => {
              t3._polling && t3.startPolling(e3);
            }), e3);
          }
          stopPolling() {
            window.clearTimeout(this._polling), delete this._polling;
          }
          whatIs(e3) {
            return this.metadata.columns[e3];
          }
        }
        return (r = a || (a = {})).types = {}, r.registerType = function(e3, t3) {
          return !!e3 && !r.types[e3] && !!(r.types[e3] = t3);
        }, a;
      }), s(t, "Data/Converters/DataConverter.js", [t["Data/DataTable.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { addEvent: s2, fireEvent: r, isNumber: o, merge: n } = t2;
        class i {
          constructor(e3) {
            this.dateFormats = { "YYYY/mm/dd": { regex: /^(\d{4})([\-\.\/])(\d{1,2})\2(\d{1,2})$/, parser: function(e4) {
              return e4 ? Date.UTC(+e4[1], e4[3] - 1, +e4[4]) : NaN;
            } }, "dd/mm/YYYY": { regex: /^(\d{1,2})([\-\.\/])(\d{1,2})\2(\d{4})$/, parser: function(e4) {
              return e4 ? Date.UTC(+e4[4], e4[3] - 1, +e4[1]) : NaN;
            }, alternative: "mm/dd/YYYY" }, "mm/dd/YYYY": { regex: /^(\d{1,2})([\-\.\/])(\d{1,2})\2(\d{4})$/, parser: function(e4) {
              return e4 ? Date.UTC(+e4[4], e4[1] - 1, +e4[3]) : NaN;
            } }, "dd/mm/YY": { regex: /^(\d{1,2})([\-\.\/])(\d{1,2})\2(\d{2})$/, parser: function(e4) {
              let t4 = /* @__PURE__ */ new Date();
              if (!e4) return NaN;
              let s4 = +e4[4];
              return s4 > t4.getFullYear() - 2e3 ? s4 += 1900 : s4 += 2e3, Date.UTC(s4, e4[3] - 1, +e4[1]);
            }, alternative: "mm/dd/YY" }, "mm/dd/YY": { regex: /^(\d{1,2})([\-\.\/])(\d{1,2})\2(\d{2})$/, parser: function(e4) {
              return e4 ? Date.UTC(+e4[4] + 2e3, e4[1] - 1, +e4[3]) : NaN;
            } } };
            let t3 = n(i.defaultOptions, e3), s3 = t3.decimalPoint;
            ("." === s3 || "," === s3) && (s3 = "." === s3 ? "\\." : ",", this.decimalRegExp = RegExp("^(-?[0-9]+)" + s3 + "([0-9]+)$")), this.options = t3;
          }
          asBoolean(e3) {
            return "boolean" == typeof e3 ? e3 : "string" == typeof e3 ? "" !== e3 && "0" !== e3 && "false" !== e3 : !!this.asNumber(e3);
          }
          asDate(e3) {
            let t3;
            if ("string" == typeof e3) t3 = this.parseDate(e3);
            else if ("number" == typeof e3) t3 = e3;
            else {
              if (e3 instanceof Date) return e3;
              t3 = this.parseDate(this.asString(e3));
            }
            return new Date(t3);
          }
          asGuessedType(e3) {
            return { number: this.asNumber, Date: this.asDate, string: this.asString }[this.guessType(e3)].call(this, e3);
          }
          asNumber(e3) {
            if ("number" == typeof e3) return e3;
            if ("boolean" == typeof e3) return e3 ? 1 : 0;
            if ("string" == typeof e3) {
              let t3 = this.decimalRegExp;
              if (e3.indexOf(" ") > -1 && (e3 = e3.replace(/\s+/g, "")), t3) {
                if (!t3.test(e3)) return NaN;
                e3 = e3.replace(t3, "$1.$2");
              }
              return parseFloat(e3);
            }
            return e3 instanceof Date ? e3.getDate() : e3 ? e3.getRowCount() : NaN;
          }
          asString(e3) {
            return "" + e3;
          }
          deduceDateFormat(e3, t3, s3) {
            let r2 = [], o2 = [], n2 = "YYYY/mm/dd", i2, l = [], a = 0, u = false, h, m;
            for ((!t3 || t3 > e3.length) && (t3 = e3.length); a < t3; a++) if (void 0 !== e3[a] && e3[a] && e3[a].length) for (m = 0, i2 = e3[a].trim().replace(/[\-\.\/]/g, " ").split(" "), l = ["", "", ""]; m < i2.length; m++) m < l.length && (h = parseInt(i2[m], 10)) && (o2[m] = !o2[m] || o2[m] < h ? h : o2[m], void 0 !== r2[m] ? r2[m] !== h && (r2[m] = false) : r2[m] = h, h > 31 ? h < 100 ? l[m] = "YY" : l[m] = "YYYY" : h > 12 && h <= 31 ? (l[m] = "dd", u = true) : l[m].length || (l[m] = "mm"));
            if (u) {
              for (m = 0; m < r2.length; m++) false !== r2[m] ? o2[m] > 12 && "YY" !== l[m] && "YYYY" !== l[m] && (l[m] = "YY") : o2[m] > 12 && "mm" === l[m] && (l[m] = "dd");
              3 === l.length && "dd" === l[1] && "dd" === l[2] && (l[2] = "YY"), n2 = l.join("/");
            }
            return s3 && (this.options.dateFormat = n2), n2;
          }
          emit(e3) {
            r(this, e3.type, e3);
          }
          export(e3, t3) {
            throw this.emit({ type: "exportError", columns: [], headers: [] }), Error("Not implemented");
          }
          getTable() {
            throw Error("Not implemented");
          }
          guessType(e3) {
            let t3 = "string";
            if ("string" == typeof e3) {
              let s3 = this.trim(`${e3}`), r2 = this.decimalRegExp, n2 = this.trim(s3, true);
              r2 && (n2 = r2.test(n2) ? n2.replace(r2, "$1.$2") : "");
              let i2 = parseFloat(n2);
              +n2 === i2 ? e3 = i2 : t3 = o(this.parseDate(e3)) ? "Date" : "string";
            }
            return "number" == typeof e3 && (t3 = e3 > 31536e6 ? "Date" : "number"), t3;
          }
          on(e3, t3) {
            return s2(this, e3, t3);
          }
          parse(e3) {
            throw this.emit({ type: "parseError", columns: [], headers: [] }), Error("Not implemented");
          }
          parseDate(e3, t3) {
            let s3 = this.options, r2 = t3 || s3.dateFormat, n2 = NaN, i2, l, a;
            if (s3.parseDate) n2 = s3.parseDate(e3);
            else {
              if (r2) (l = this.dateFormats[r2]) || (l = this.dateFormats["YYYY/mm/dd"]), (a = e3.match(l.regex)) && (n2 = l.parser(a));
              else for (i2 in this.dateFormats) if (l = this.dateFormats[i2], a = e3.match(l.regex)) {
                r2 = i2, n2 = l.parser(a);
                break;
              }
              !a && ("object" == typeof (a = Date.parse(e3)) && null !== a && a.getTime ? n2 = a.getTime() - 6e4 * a.getTimezoneOffset() : o(a) && (n2 = a - 6e4 * new Date(a).getTimezoneOffset(), -1 === e3.indexOf("2001") && 2001 === new Date(n2).getFullYear() && (n2 = NaN)));
            }
            return n2;
          }
          trim(e3, t3) {
            return "string" == typeof e3 && (e3 = e3.replace(/^\s+|\s+$/g, ""), t3 && /^[\d\s]+$/.test(e3) && (e3 = e3.replace(/\s/g, ""))), e3;
          }
        }
        return i.defaultOptions = { dateFormat: "", alternativeFormat: "", startColumn: 0, endColumn: Number.MAX_VALUE, startRow: 0, endRow: Number.MAX_VALUE, firstRowAsNames: true, switchRowsAndColumns: false }, (i || (i = {})).getTableFromColumns = function(t3 = [], s3 = []) {
          let r2 = new e2();
          for (let e3 = 0, o2 = Math.max(s3.length, t3.length); e3 < o2; ++e3) r2.setColumn(s3[e3] || `${e3}`, t3[e3]);
          return r2;
        }, i;
      }), s(t, "Data/DataCursor.js", [], function() {
        class e2 {
          constructor(e3 = {}) {
            this.emittingRegister = [], this.listenerMap = {}, this.stateMap = e3;
          }
          addListener(e3, t2, s2) {
            let r = this.listenerMap[e3] = this.listenerMap[e3] || {};
            return (r[t2] = r[t2] || []).push(s2), this;
          }
          buildEmittingTag(e3) {
            return ("position" === e3.cursor.type ? [e3.table.id, e3.cursor.column, e3.cursor.row, e3.cursor.state, e3.cursor.type] : [e3.table.id, e3.cursor.columns, e3.cursor.firstRow, e3.cursor.lastRow, e3.cursor.state, e3.cursor.type]).join("\0");
          }
          emitCursor(t2, s2, r, o) {
            let n = t2.id, i = s2.state, l = this.listenerMap[n] && this.listenerMap[n][i];
            if (l) {
              let i2 = this.stateMap[n] = this.stateMap[n] ?? {}, a = i2[s2.state] || [];
              o && (a.length || (i2[s2.state] = a), -1 === e2.getIndex(s2, a) && a.push(s2));
              let u = { cursor: s2, cursors: a, table: t2 };
              r && (u.event = r);
              let h = this.emittingRegister, m = this.buildEmittingTag(u);
              if (h.indexOf(m) >= 0) return this;
              try {
                this.emittingRegister.push(m);
                for (let e3 = 0, t3 = l.length; e3 < t3; ++e3) l[e3].call(this, u);
              } finally {
                let e3 = this.emittingRegister.indexOf(m);
                e3 >= 0 && this.emittingRegister.splice(e3, 1);
              }
            }
            return this;
          }
          remitCursor(t2, s2) {
            let r = this.stateMap[t2] && this.stateMap[t2][s2.state];
            if (r) {
              let t3 = e2.getIndex(s2, r);
              t3 >= 0 && r.splice(t3, 1);
            }
            return this;
          }
          removeListener(e3, t2, s2) {
            let r = this.listenerMap[e3] && this.listenerMap[e3][t2];
            if (r) {
              let e4 = r.indexOf(s2);
              e4 >= 0 && r.splice(e4, 1);
            }
            return this;
          }
        }
        return e2.version = "1.0.0", function(e3) {
          function t2(e4, t3) {
            if ("range" === e4.type) return e4;
            let s2 = { type: "range", firstRow: e4.row ?? (t3 && t3.firstRow) ?? 0, lastRow: e4.row ?? (t3 && t3.lastRow) ?? Number.MAX_VALUE, state: e4.state };
            return void 0 !== e4.column && (s2.columns = [e4.column]), s2;
          }
          e3.getIndex = function(e4, t3) {
            if ("position" === e4.type) {
              for (let s2, r = 0, o = t3.length; r < o; ++r) if ("position" === (s2 = t3[r]).type && s2.state === e4.state && s2.column === e4.column && s2.row === e4.row) return r;
            } else {
              let s2 = JSON.stringify(e4.columns);
              for (let r, o = 0, n = t3.length; o < n; ++o) if ("range" === (r = t3[o]).type && r.state === e4.state && r.firstRow === e4.firstRow && r.lastRow === e4.lastRow && JSON.stringify(r.columns) === s2) return o;
            }
            return -1;
          }, e3.isEqual = function(e4, t3) {
            return "position" === e4.type && "position" === t3.type ? e4.column === t3.column && e4.row === t3.row && e4.state === t3.state : "range" === e4.type && "range" === t3.type && e4.firstRow === t3.firstRow && e4.lastRow === t3.lastRow && JSON.stringify(e4.columns) === JSON.stringify(t3.columns);
          }, e3.isInRange = function(e4, s2) {
            "position" === s2.type && (s2 = t2(s2)), "position" === e4.type && (e4 = t2(e4, s2));
            let r = e4.columns, o = s2.columns;
            return e4.firstRow >= s2.firstRow && e4.lastRow <= s2.lastRow && (!r || !o || r.every((e5) => o.indexOf(e5) >= 0));
          }, e3.toPositions = function(e4) {
            if ("position" === e4.type) return [e4];
            let t3 = e4.columns || [], s2 = [], r = e4.state;
            for (let o = e4.firstRow, n = e4.lastRow; o < n; ++o) {
              if (!t3.length) {
                s2.push({ type: "position", row: o, state: r });
                continue;
              }
              for (let e5 = 0, n2 = t3.length; e5 < n2; ++e5) s2.push({ type: "position", column: t3[e5], row: o, state: r });
            }
            return s2;
          }, e3.toRange = t2;
        }(e2 || (e2 = {})), e2;
      }), s(t, "Data/DataPoolDefaults.js", [], function() {
        return { connectors: [] };
      }), s(t, "Data/DataPool.js", [t["Data/Connectors/DataConnector.js"], t["Data/DataPoolDefaults.js"], t["Core/Utilities.js"]], function(e2, t2, s2) {
        class r {
          constructor(e3 = t2) {
            e3.connectors = e3.connectors || [], this.connectors = {}, this.options = e3, this.waiting = {};
          }
          emit(e3) {
            s2.fireEvent(this, e3.type, e3);
          }
          getConnector(e3) {
            let t3 = this.connectors[e3];
            if (t3) return Promise.resolve(t3);
            let s3 = this.waiting[e3];
            if (!s3) {
              s3 = this.waiting[e3] = [];
              let t4 = this.getConnectorOptions(e3);
              if (!t4) throw Error(`Connector '${e3}' not found.`);
              this.loadConnector(t4).then((t5) => {
                delete this.waiting[e3];
                for (let e4 = 0, r2 = s3.length; e4 < r2; ++e4) s3[e4][0](t5);
              }).catch((t5) => {
                delete this.waiting[e3];
                for (let e4 = 0, r2 = s3.length; e4 < r2; ++e4) s3[e4][1](t5);
              });
            }
            return new Promise((e4, t4) => {
              s3.push([e4, t4]);
            });
          }
          getConnectorIds() {
            let e3 = this.options.connectors, t3 = [];
            for (let s3 = 0, r2 = e3.length; s3 < r2; ++s3) t3.push(e3[s3].id);
            return t3;
          }
          getConnectorOptions(e3) {
            let t3 = this.options.connectors;
            for (let s3 = 0, r2 = t3.length; s3 < r2; ++s3) if (t3[s3].id === e3) return t3[s3];
          }
          getConnectorTable(e3) {
            return this.getConnector(e3).then((e4) => e4.table);
          }
          isNewConnector(e3) {
            return !this.connectors[e3];
          }
          loadConnector(t3) {
            return new Promise((s3, r2) => {
              this.emit({ type: "load", options: t3 });
              let o = e2.types[t3.type];
              if (!o) throw Error(`Connector type not found. (${t3.type})`);
              new o(t3.options).load().then((e3) => {
                this.connectors[t3.id] = e3, this.emit({ type: "afterLoad", options: t3 }), s3(e3);
              }).catch(r2);
            });
          }
          on(e3, t3) {
            return s2.addEvent(this, e3, t3);
          }
          setConnectorOptions(e3) {
            let t3 = this.options.connectors, s3 = this.connectors;
            this.emit({ type: "setConnectorOptions", options: e3 });
            for (let s4 = 0, r2 = t3.length; s4 < r2; ++s4) if (t3[s4].id === e3.id) {
              t3.splice(s4, 1);
              break;
            }
            s3[e3.id] && (s3[e3.id].stopPolling(), delete s3[e3.id]), t3.push(e3), this.emit({ type: "afterSetConnectorOptions", options: e3 });
          }
        }
        return r.version = "1.0.0", r;
      }), s(t, "Data/Formula/FormulaParser.js", [], function() {
        let e2 = /^(?:FALSE|TRUE)/, t2 = /^[+\-]?\d+(?:\.\d+)?(?:e[+\-]\d+)?/, s2 = /^[+\-]?\d+(?:,\d+)?(?:e[+\-]\d+)?/, r = /^([A-Z][A-Z\d\.]*)\(/, o = /^(?:[+\-*\/^<=>]|<=|=>)/, n = /^(\$?[A-Z]+)(\$?\d+)\:(\$?[A-Z]+)(\$?\d+)/, i = /^R(\d*|\[\d+\])C(\d*|\[\d+\])\:R(\d*|\[\d+\])C(\d*|\[\d+\])/, l = /^(\$?[A-Z]+)(\$?\d+)(?![\:C])/, a = /^R(\d*|\[\d+\])C(\d*|\[\d+\])(?!\:)/;
        function u(e3) {
          let t3 = 0;
          for (let s3 = 0, r2 = e3.length, o2, n2 = 1; s3 < r2; ++s3) {
            if ("(" === (o2 = e3[s3])) {
              t3 || (n2 = s3 + 1), ++t3;
              continue;
            }
            if (")" === o2 && !--t3) return e3.substring(n2, s3);
          }
          if (t3 > 0) {
            let e4 = Error("Incomplete parantheses.");
            throw e4.name = "FormulaParseError", e4;
          }
          return "";
        }
        function h(e3) {
          let t3 = -1;
          for (let s4 = 0, r2 = e3.length, o2, n2 = false; s4 < r2; ++s4) {
            if ("\\" === (o2 = e3[s4])) {
              n2 = !n2;
              continue;
            }
            if (n2) {
              n2 = false;
              continue;
            }
            if ('"' === o2) {
              if (!(t3 < 0)) return e3.substring(t3 + 1, s4);
              t3 = s4;
            }
          }
          let s3 = Error("Incomplete string.");
          throw s3.name = "FormulaParseError", s3;
        }
        function m(e3, t3) {
          let s3;
          if (s3 = e3.match(i)) {
            let e4 = "" === s3[2] || "[" === s3[2][0], t4 = "" === s3[1] || "[" === s3[1][0], r3 = "" === s3[4] || "[" === s3[4][0], o2 = "" === s3[3] || "[" === s3[3][0], n2 = { type: "range", beginColumn: e4 ? parseInt(s3[2].substring(1, -1) || "0", 10) : parseInt(s3[2], 10) - 1, beginRow: t4 ? parseInt(s3[1].substring(1, -1) || "0", 10) : parseInt(s3[1], 10) - 1, endColumn: r3 ? parseInt(s3[4].substring(1, -1) || "0", 10) : parseInt(s3[4], 10) - 1, endRow: o2 ? parseInt(s3[3].substring(1, -1) || "0", 10) : parseInt(s3[3], 10) - 1 };
            return e4 && (n2.beginColumnRelative = true), t4 && (n2.beginRowRelative = true), r3 && (n2.endColumnRelative = true), o2 && (n2.endRowRelative = true), n2;
          }
          if (s3 = e3.match(n)) {
            let e4 = "$" !== s3[1][0], t4 = "$" !== s3[2][0], r3 = "$" !== s3[3][0], o2 = "$" !== s3[4][0], n2 = { type: "range", beginColumn: f(e4 ? s3[1] : s3[1].substring(1)) - 1, beginRow: parseInt(t4 ? s3[2] : s3[2].substring(1), 10) - 1, endColumn: f(r3 ? s3[3] : s3[3].substring(1)) - 1, endRow: parseInt(o2 ? s3[4] : s3[4].substring(1), 10) - 1 };
            return e4 && (n2.beginColumnRelative = true), t4 && (n2.beginRowRelative = true), r3 && (n2.endColumnRelative = true), o2 && (n2.endRowRelative = true), n2;
          }
          let r2 = c(e3, t3);
          return 1 === r2.length && "string" != typeof r2[0] ? r2[0] : r2;
        }
        function c(n2, i2) {
          let d = i2 ? s2 : t2, p = [], g, y = ("=" === n2[0] ? n2.substring(1) : n2).trim();
          for (; y; ) {
            if (g = y.match(a)) {
              let e3 = "" === g[2] || "[" === g[2][0], t4 = "" === g[1] || "[" === g[1][0], s4 = { type: "reference", column: e3 ? parseInt(g[2].substring(1, -1) || "0", 10) : parseInt(g[2], 10) - 1, row: t4 ? parseInt(g[1].substring(1, -1) || "0", 10) : parseInt(g[1], 10) - 1 };
              e3 && (s4.columnRelative = true), t4 && (s4.rowRelative = true), p.push(s4), y = y.substring(g[0].length).trim();
              continue;
            }
            if (g = y.match(l)) {
              let e3 = "$" !== g[1][0], t4 = "$" !== g[2][0], s4 = { type: "reference", column: f(e3 ? g[1] : g[1].substring(1)) - 1, row: parseInt(t4 ? g[2] : g[2].substring(1), 10) - 1 };
              e3 && (s4.columnRelative = true), t4 && (s4.rowRelative = true), p.push(s4), y = y.substring(g[0].length).trim();
              continue;
            }
            if (g = y.match(o)) {
              p.push(g[0]), y = y.substring(g[0].length).trim();
              continue;
            }
            if (g = y.match(e2)) {
              p.push("TRUE" === g[0]), y = y.substring(g[0].length).trim();
              continue;
            }
            if (g = y.match(d)) {
              p.push(parseFloat(g[0])), y = y.substring(g[0].length).trim();
              continue;
            }
            if ('"' === y[0]) {
              let e3 = h(y);
              p.push(e3.substring(1, -1)), y = y.substring(e3.length + 2).trim();
              continue;
            }
            if (g = y.match(r)) {
              let e3 = u(y = y.substring(g[1].length).trim());
              p.push({ type: "function", name: g[1], args: function(e4, t4) {
                let s4 = [], r2 = t4 ? ";" : ",", o2 = 0, n3 = "";
                for (let i3 = 0, l2 = e4.length, a2; i3 < l2; ++i3) if ((a2 = e4[i3]) === r2 && !o2 && n3) s4.push(m(n3, t4)), n3 = "";
                else if ('"' !== a2 || o2 || n3) " " !== a2 && (n3 += a2, "(" === a2 ? ++o2 : ")" === a2 && --o2);
                else {
                  let t5 = h(e4.substring(i3));
                  s4.push(t5), i3 += t5.length + 1;
                }
                return !o2 && n3 && s4.push(m(n3, t4)), s4;
              }(e3, i2) }), y = y.substring(e3.length + 2).trim();
              continue;
            }
            if ("(" === y[0]) {
              let e3 = u(y);
              if (e3) {
                p.push(c(e3, i2)), y = y.substring(e3.length + 2).trim();
                continue;
              }
            }
            let t3 = n2.length - y.length, s3 = Error("Unexpected character `" + n2.substring(t3, t3 + 1) + "` at position " + (t3 + 1) + ". (`..." + n2.substring(t3 - 5, t3 + 6) + "...`)");
            throw s3.name = "FormulaParseError", s3;
          }
          return p;
        }
        function f(e3) {
          let t3 = 0;
          for (let s3 = 0, r2 = e3.length, o2, n2 = e3.length - 1; s3 < r2; ++s3) (o2 = e3.charCodeAt(s3)) >= 65 && o2 <= 90 && (t3 += (o2 - 64) * Math.pow(26, n2)), --n2;
          return t3;
        }
        return { parseFormula: c };
      }), s(t, "Data/Formula/FormulaTypes.js", [], function() {
        let e2 = ["+", "-", "*", "/", "^", "=", "<", "<=", ">", ">="];
        return { isFormula: function(e3) {
          return e3 instanceof Array;
        }, isFunction: function(e3) {
          return "object" == typeof e3 && !(e3 instanceof Array) && "function" === e3.type;
        }, isOperator: function(t2) {
          return "string" == typeof t2 && e2.indexOf(t2) >= 0;
        }, isRange: function(e3) {
          return "object" == typeof e3 && !(e3 instanceof Array) && "range" === e3.type;
        }, isReference: function(e3) {
          return "object" == typeof e3 && !(e3 instanceof Array) && "reference" === e3.type;
        }, isValue: function(e3) {
          return "boolean" == typeof e3 || "number" == typeof e3 || "string" == typeof e3;
        } };
      }), s(t, "Data/Formula/FormulaProcessor.js", [t["Data/Formula/FormulaTypes.js"]], function(e2) {
        let { isFormula: t2, isFunction: s2, isOperator: r, isRange: o, isReference: n, isValue: i } = e2, l = / */, a = Number.MAX_VALUE / 1.000000000001, u = Number.MAX_VALUE / 1.000000000002, h = Number.MAX_VALUE, m = { "^": 3, "*": 2, "/": 2, "+": 1, "-": 1, "=": 0, "<": 0, "<=": 0, ">": 0, ">=": 0 }, c = {}, f = /^[A-Z][A-Z\.]*$/;
        function d(e3) {
          switch (typeof e3) {
            case "boolean":
              return e3 ? h : a;
            case "string":
              return u;
            case "number":
              return e3;
            default:
              return NaN;
          }
        }
        function p(e3) {
          return "string" == typeof e3 ? e3.toLowerCase().replace(l, "\0") : e3;
        }
        function g(e3) {
          switch (typeof e3) {
            case "boolean":
              return e3 ? 1 : 0;
            case "string":
              return parseFloat(e3.replace(",", "."));
            case "number":
              return e3;
            default:
              return NaN;
          }
        }
        function y(e3, t3, s3) {
          let r2;
          switch (e3) {
            case "=":
              return p(t3) === p(s3);
            case "<":
              if (typeof t3 == typeof s3) return p(t3) < p(s3);
              return d(t3) < d(s3);
            case "<=":
              if (typeof t3 == typeof s3) return p(t3) <= p(s3);
              return d(t3) <= d(s3);
            case ">":
              if (typeof t3 == typeof s3) return p(t3) > p(s3);
              return d(t3) > d(s3);
            case ">=":
              if (typeof t3 == typeof s3) return p(t3) >= p(s3);
              return d(t3) >= d(s3);
          }
          switch (t3 = g(t3), s3 = g(s3), e3) {
            case "+":
              r2 = t3 + s3;
              break;
            case "-":
              r2 = t3 - s3;
              break;
            case "*":
              r2 = t3 * s3;
              break;
            case "/":
              r2 = t3 / s3;
              break;
            case "^":
              r2 = Math.pow(t3, s3);
              break;
            default:
              return NaN;
          }
          return r2 % 1 ? Math.round(1e9 * r2) / 1e9 : r2;
        }
        function C(e3, r2) {
          return i(e3) ? e3 : o(e3) ? r2 && b(e3, r2) || [] : s2(e3) ? N(e3, r2) : D(t2(e3) ? e3 : [e3], r2);
        }
        function b(e3, t3) {
          let s3 = t3.getColumnNames().slice(e3.beginColumn, e3.endColumn + 1), r2 = [];
          for (let o2 = 0, n2 = s3.length, l2; o2 < n2; ++o2) {
            let n3 = t3.getColumn(s3[o2], true) || [];
            for (let a2 = e3.beginRow, u2 = e3.endRow + 1; a2 < u2; ++a2) "string" == typeof (l2 = n3[a2]) && "=" === l2[0] && t3 !== t3.modified && (l2 = t3.modified.getCell(s3[o2], a2)), r2.push(i(l2) ? l2 : NaN);
          }
          return r2;
        }
        function w(e3, t3) {
          let s3 = t3.getColumnNames()[e3.column];
          if (s3) {
            let r2 = t3.getCell(s3, e3.row);
            if ("string" == typeof r2 && "=" === r2[0] && t3 !== t3.modified) {
              let r3 = t3.modified.getCell(s3, e3.row);
              return i(r3) ? r3 : NaN;
            }
            return i(r2) ? r2 : NaN;
          }
          return NaN;
        }
        function D(e3, o2) {
          let l2;
          for (let a2 = 0, u2 = e3.length, h2, c2, f2, d2; a2 < u2; ++a2) {
            if (r(h2 = e3[a2])) {
              c2 = h2;
              continue;
            }
            if (i(h2) ? d2 = h2 : t2(h2) ? d2 = D(e3, o2) : s2(h2) ? d2 = i(f2 = N(h2, o2)) ? f2 : NaN : n(h2) && (d2 = o2 && w(h2, o2)), void 0 !== d2) {
              if (void 0 === l2) l2 = c2 ? y(c2, 0, d2) : d2;
              else {
                if (!c2) return NaN;
                let t3 = e3[a2 + 1];
                r(t3) && m[t3] > m[c2] && (d2 = y(t3, d2, D(e3.slice(a2 + 2))), a2 = u2), l2 = y(c2, l2, d2);
              }
              c2 = void 0, d2 = void 0;
            }
          }
          return i(l2) ? l2 : NaN;
        }
        function N(e3, t3, s3) {
          let r2 = c[e3.name];
          if (r2) try {
            return r2(e3.args, t3);
          } catch {
            return NaN;
          }
          let o2 = Error(`Function "${e3.name}" not found.`);
          throw o2.name = "FormulaProcessError", o2;
        }
        return { asNumber: g, getArgumentValue: C, getArgumentsValues: function(e3, t3) {
          let s3 = [];
          for (let r2 = 0, o2 = e3.length; r2 < o2; ++r2) s3.push(C(e3[r2], t3));
          return s3;
        }, getRangeValues: b, getReferenceValue: w, processFormula: D, processorFunctions: c, registerProcessorFunction: function(e3, t3) {
          return f.test(e3) && !c[e3] && !!(c[e3] = t3);
        }, translateReferences: function e3(t3, r2 = 0, i2 = 0) {
          for (let l2 = 0, a2 = t3.length, u2; l2 < a2; ++l2) (u2 = t3[l2]) instanceof Array ? e3(u2, r2, i2) : s2(u2) ? e3(u2.args, r2, i2) : o(u2) ? (u2.beginColumnRelative && (u2.beginColumn += r2), u2.beginRowRelative && (u2.beginRow += i2), u2.endColumnRelative && (u2.endColumn += r2), u2.endRowRelative && (u2.endRow += i2)) : n(u2) && (u2.columnRelative && (u2.column += r2), u2.rowRelative && (u2.row += i2));
          return t3;
        } };
      }), s(t, "Data/Formula/Functions/ABS.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        let { getArgumentValue: t2 } = e2;
        function s2(e3, s3) {
          let r = t2(e3[0], s3);
          switch (typeof r) {
            case "number":
              return Math.abs(r);
            case "object": {
              let e4 = [];
              for (let t3 = 0, s4 = r.length, o; t3 < s4; ++t3) {
                if ("number" != typeof (o = r[t3])) return NaN;
                e4.push(Math.abs(o));
              }
              return e4;
            }
            default:
              return NaN;
          }
        }
        return e2.registerProcessorFunction("ABS", s2), s2;
      }), s(t, "Data/Formula/Functions/AND.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        let { getArgumentValue: t2 } = e2;
        function s2(e3, r) {
          for (let o = 0, n = e3.length, i; o < n; ++o) if (!(i = t2(e3[o], r)) || "object" == typeof i && !s2(i, r)) return false;
          return true;
        }
        return e2.registerProcessorFunction("AND", s2), s2;
      }), s(t, "Data/Formula/Functions/AVERAGE.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        let { getArgumentsValues: t2 } = e2;
        function s2(e3, s3) {
          let r = t2(e3, s3), o = 0, n = 0;
          for (let e4 = 0, t3 = r.length, s4; e4 < t3; ++e4) switch (typeof (s4 = r[e4])) {
            case "number":
              isNaN(s4) || (++o, n += s4);
              break;
            case "object":
              for (let e5 = 0, t4 = s4.length, r2; e5 < t4; ++e5) "number" != typeof (r2 = s4[e5]) || isNaN(r2) || (++o, n += r2);
          }
          return o ? n / o : 0;
        }
        return e2.registerProcessorFunction("AVERAGE", s2), s2;
      }), s(t, "Data/Formula/Functions/AVERAGEA.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        let { getArgumentValue: t2 } = e2;
        function s2(e3, s3) {
          let r = 0, o = 0;
          for (let n = 0, i = e3.length, l; n < i; ++n) switch (typeof (l = t2(e3[n], s3))) {
            case "boolean":
              ++r, o += l ? 1 : 0;
              continue;
            case "number":
              isNaN(l) || (++r, o += l);
              continue;
            case "string":
              ++r;
              continue;
            default:
              for (let e4 = 0, t3 = l.length, s4; e4 < t3; ++e4) switch (typeof (s4 = l[e4])) {
                case "boolean":
                  ++r, o += s4 ? 1 : 0;
                  continue;
                case "number":
                  isNaN(s4) || (++r, o += s4);
                  continue;
                case "string":
                  ++r;
                  continue;
              }
              continue;
          }
          return r ? o / r : 0;
        }
        return e2.registerProcessorFunction("AVERAGEA", s2), s2;
      }), s(t, "Data/Formula/Functions/COUNT.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        function t2(s2, r) {
          let o = e2.getArgumentsValues(s2, r), n = 0;
          for (let e3 = 0, s3 = o.length, i; e3 < s3; ++e3) switch (typeof (i = o[e3])) {
            case "number":
              !isNaN(i) && ++n;
              break;
            case "object":
              n += t2(i, r);
          }
          return n;
        }
        return e2.registerProcessorFunction("COUNT", t2), t2;
      }), s(t, "Data/Formula/Functions/COUNTA.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        function t2(s2, r) {
          let o = e2.getArgumentsValues(s2, r), n = 0;
          for (let e3 = 0, s3 = o.length, i; e3 < s3; ++e3) {
            switch (typeof (i = o[e3])) {
              case "number":
                if (isNaN(i)) continue;
                break;
              case "object":
                n += t2(i, r);
                continue;
              case "string":
                if (!i) continue;
            }
            ++n;
          }
          return n;
        }
        return e2.registerProcessorFunction("COUNTA", t2), t2;
      }), s(t, "Data/Formula/Functions/IF.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        let { getArgumentValue: t2 } = e2;
        function s2(e3, s3) {
          return t2(e3[0], s3) ? t2(e3[1], s3) : t2(e3[2], s3);
        }
        return e2.registerProcessorFunction("IF", s2), s2;
      }), s(t, "Data/Formula/Functions/ISNA.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        let { getArgumentValue: t2 } = e2;
        function s2(e3, s3) {
          let r = t2(e3[0], s3);
          return "number" != typeof r || isNaN(r);
        }
        return e2.registerProcessorFunction("ISNA", s2), s2;
      }), s(t, "Data/Formula/Functions/MAX.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        let { getArgumentsValues: t2 } = e2;
        function s2(e3, r) {
          let o = t2(e3, r), n = Number.NEGATIVE_INFINITY;
          for (let e4 = 0, t3 = o.length, r2; e4 < t3; ++e4) switch (typeof (r2 = o[e4])) {
            case "number":
              r2 > n && (n = r2);
              break;
            case "object":
              (r2 = s2(r2)) > n && (n = r2);
          }
          return isFinite(n) ? n : 0;
        }
        return e2.registerProcessorFunction("MAX", s2), s2;
      }), s(t, "Data/Formula/Functions/MEDIAN.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        function t2(t3, s2) {
          let r = [], o = e2.getArgumentsValues(t3, s2);
          for (let e3 = 0, t4 = o.length, s3; e3 < t4; ++e3) switch (typeof (s3 = o[e3])) {
            case "number":
              isNaN(s3) || r.push(s3);
              break;
            case "object":
              for (let e4 = 0, t5 = s3.length, o2; e4 < t5; ++e4) "number" != typeof (o2 = s3[e4]) || isNaN(o2) || r.push(o2);
          }
          let n = r.length;
          if (!n) return NaN;
          let i = Math.floor(n / 2);
          return n % 2 ? r[i] : (r[i - 1] + r[i]) / 2;
        }
        return e2.registerProcessorFunction("MEDIAN", t2), t2;
      }), s(t, "Data/Formula/Functions/MIN.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        let { getArgumentsValues: t2 } = e2;
        function s2(e3, r) {
          let o = t2(e3, r), n = Number.POSITIVE_INFINITY;
          for (let e4 = 0, t3 = o.length, r2; e4 < t3; ++e4) switch (typeof (r2 = o[e4])) {
            case "number":
              r2 < n && (n = r2);
              break;
            case "object":
              (r2 = s2(r2)) < n && (n = r2);
          }
          return isFinite(n) ? n : 0;
        }
        return e2.registerProcessorFunction("MIN", s2), s2;
      }), s(t, "Data/Formula/Functions/MOD.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        let { getArgumentValue: t2 } = e2;
        function s2(e3, s3) {
          let r = t2(e3[0], s3), o = t2(e3[1], s3);
          return ("object" == typeof r && (r = r[0]), "object" == typeof o && (o = o[0]), "number" != typeof r || "number" != typeof o || 0 === o) ? NaN : r % o;
        }
        return e2.registerProcessorFunction("MOD", s2), s2;
      }), s(t, "Data/Formula/Functions/MODE.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        function t2(t3, s3) {
          let r2 = {}, o = e2.getArgumentsValues(t3, s3);
          for (let e3 = 0, t4 = o.length, s4; e3 < t4; ++e3) switch (typeof (s4 = o[e3])) {
            case "number":
              isNaN(s4) || (r2[s4] = (r2[s4] || 0) + 1);
              break;
            case "object":
              for (let e4 = 0, t5 = s4.length, o2; e4 < t5; ++e4) "number" != typeof (o2 = s4[e4]) || isNaN(o2) || (r2[o2] = (r2[o2] || 0) + 1);
          }
          return r2;
        }
        function s2(e3, s3) {
          let r2 = t2(e3, s3), o = Object.keys(r2);
          if (!o.length) return NaN;
          let n = [parseFloat(o[0])], i = r2[o[0]];
          for (let e4 = 1, t3 = o.length, s4, l; e4 < t3; ++e4) i < (l = r2[s4 = o[e4]]) ? (n = [parseFloat(s4)], i = l) : i === l && n.push(parseFloat(s4));
          return i > 1 ? n : NaN;
        }
        function r(e3, s3) {
          let r2 = t2(e3, s3), o = Object.keys(r2);
          if (!o.length) return NaN;
          let n = parseFloat(o[0]), i = r2[o[0]];
          for (let e4 = 1, t3 = o.length, s4, l, a; e4 < t3; ++e4) i < (a = r2[s4 = o[e4]]) ? (n = parseFloat(s4), i = a) : i === a && n > (l = parseFloat(s4)) && (n = l, i = a);
          return i > 1 ? n : NaN;
        }
        return e2.registerProcessorFunction("MODE", r), e2.registerProcessorFunction("MODE.MULT", s2), e2.registerProcessorFunction("MODE.SNGL", r), { MULT: s2, SNGL: r };
      }), s(t, "Data/Formula/Functions/NOT.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        let { getArgumentValue: t2 } = e2;
        function s2(e3, s3) {
          let r = t2(e3[0], s3);
          switch ("object" == typeof r && (r = r[0]), typeof r) {
            case "boolean":
            case "number":
              return !r;
          }
          return NaN;
        }
        return e2.registerProcessorFunction("NOT", s2), s2;
      }), s(t, "Data/Formula/Functions/OR.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        let { getArgumentValue: t2 } = e2;
        function s2(e3, r) {
          for (let o = 0, n = e3.length, i; o < n; ++o) if ("object" == typeof (i = t2(e3[o], r))) {
            if (s2(i, r)) return true;
          } else if (i) return true;
          return false;
        }
        return e2.registerProcessorFunction("OR", s2), s2;
      }), s(t, "Data/Formula/Functions/PRODUCT.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        let { getArgumentsValues: t2 } = e2;
        function s2(e3, r) {
          let o = t2(e3, r), n = 1, i = false;
          for (let e4 = 0, t3 = o.length, l; e4 < t3; ++e4) switch (typeof (l = o[e4])) {
            case "number":
              isNaN(l) || (i = true, n *= l);
              break;
            case "object":
              i = true, n *= s2(l, r);
          }
          return i ? n : 0;
        }
        return e2.registerProcessorFunction("PRODUCT", s2), s2;
      }), s(t, "Data/Formula/Functions/SUM.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        function t2(s2, r) {
          let o = e2.getArgumentsValues(s2, r), n = 0;
          for (let e3 = 0, s3 = o.length, i; e3 < s3; ++e3) switch (typeof (i = o[e3])) {
            case "number":
              isNaN(i) || (n += i);
              break;
            case "object":
              n += t2(i, r);
          }
          return n;
        }
        return e2.registerProcessorFunction("SUM", t2), t2;
      }), s(t, "Data/Formula/Functions/XOR.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        let { getArgumentValue: t2 } = e2;
        function s2(e3, s3) {
          for (let r = 0, o = e3.length, n, i; r < o; ++r) switch (typeof (i = t2(e3[r], s3))) {
            case "boolean":
            case "number":
              if (void 0 === n) n = !!i;
              else if (!!i !== n) return true;
              break;
            case "object":
              for (let e4 = 0, t3 = i.length, s4; e4 < t3; ++e4) switch (typeof (s4 = i[e4])) {
                case "boolean":
                case "number":
                  if (void 0 === n) n = !!s4;
                  else if (!!s4 !== n) return true;
              }
          }
          return false;
        }
        return e2.registerProcessorFunction("XOR", s2), s2;
      }), s(t, "Data/Formula/Formula.js", [t["Data/Formula/FormulaParser.js"], t["Data/Formula/FormulaProcessor.js"], t["Data/Formula/FormulaTypes.js"]], function(e2, t2, s2) {
        return { ...e2, ...t2, ...s2 };
      }), s(t, "Data/Converters/CSVConverter.js", [t["Data/Converters/DataConverter.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { merge: s2 } = t2;
        class r extends e2 {
          constructor(e3) {
            let t3 = s2(r.defaultOptions, e3);
            super(t3), this.columns = [], this.headers = [], this.dataTypes = [], this.options = t3;
          }
          export(e3, t3 = this.options) {
            let { useLocalDecimalPoint: s3, lineDelimiter: r2 } = t3, o = false !== this.options.firstRowAsNames, { decimalPoint: n, itemDelimiter: i } = t3;
            n || (n = "," !== i && s3 ? 1.1.toLocaleString()[1] : "."), i || (i = "," === n ? ";" : ",");
            let l = e3.getSortedColumns(t3.usePresentationOrder), a = Object.keys(l), u = [], h = a.length, m = [];
            o && u.push(a.map((e4) => `"${e4}"`).join(i));
            for (let t4 = 0; t4 < h; t4++) {
              let s4;
              let r3 = a[t4], o2 = l[r3], c = o2.length, f = e3.whatIs(r3);
              f && (s4 = f.dataType);
              for (let e4 = 0; e4 < c; e4++) {
                let r4 = o2[e4];
                if (m[e4] || (m[e4] = []), "string" === s4 ? r4 = '"' + r4 + '"' : "number" == typeof r4 ? r4 = String(r4).replace(".", n) : "string" == typeof r4 && (r4 = `"${r4}"`), m[e4][t4] = r4, t4 === h - 1) {
                  let s5 = t4;
                  for (; m[e4].length > 2 && void 0 === m[e4][s5]; ) m[e4].pop(), s5--;
                  u.push(m[e4].join(i));
                }
              }
            }
            return u.join(r2);
          }
          parse(e3, t3) {
            let r2 = this.dataTypes, o = s2(this.options, e3), { beforeParse: n, lineDelimiter: i, firstRowAsNames: l, itemDelimiter: a } = o, u, h = 0, { csv: m, startRow: c, endRow: f } = o, d;
            if (this.columns = [], this.emit({ type: "parse", columns: this.columns, detail: t3, headers: this.headers }), m && n && (m = n(m)), m) {
              if (u = m.replace(/\r\n|\r/g, "\n").split(i || "\n"), (!c || c < 0) && (c = 0), (!f || f >= u.length) && (f = u.length - 1), a || (this.guessedItemDelimiter = this.guessDelimiter(u)), l) {
                let e5 = u[0].split(a || this.guessedItemDelimiter || ",");
                for (let t4 = 0; t4 < e5.length; t4++) e5[t4] = e5[t4].trim().replace(/^["']|["']$/g, "");
                this.headers = e5, c++;
              }
              let e4 = 0;
              for (h = c; h <= f; h++) "#" === u[h][0] ? e4++ : this.parseCSVRow(u[h], h - c - e4);
              r2.length && r2[0].length && "date" === r2[0][1] && !this.options.dateFormat && this.deduceDateFormat(this.columns[0], null, true);
              for (let e5 = 0, t4 = this.columns.length; e5 < t4; ++e5) {
                d = this.columns[e5];
                for (let t5 = 0, s3 = d.length; t5 < s3; ++t5) if (d[t5] && "string" == typeof d[t5]) {
                  let s4 = this.asGuessedType(d[t5]);
                  s4 instanceof Date && (s4 = s4.getTime()), this.columns[e5][t5] = s4;
                }
              }
            }
            this.emit({ type: "afterParse", columns: this.columns, detail: t3, headers: this.headers });
          }
          parseCSVRow(e3, t3) {
            let s3 = this, r2 = s3.columns || [], o = s3.dataTypes, { startColumn: n, endColumn: i } = s3.options, l = s3.options.itemDelimiter || s3.guessedItemDelimiter, { decimalPoint: a } = s3.options;
            a && a !== l || (a = s3.guessedDecimalPoint || ".");
            let u = 0, h = "", m = "", c = 0, f = 0, d = (t4) => {
              h = e3[t4];
            }, p = (e4) => {
              o.length < f + 1 && o.push([e4]), o[f][o[f].length - 1] !== e4 && o[f].push(e4);
            }, g = () => {
              if (n > c || c > i) {
                ++c, m = "";
                return;
              }
              if ("string" == typeof m ? !isNaN(parseFloat(m)) && isFinite(m) ? (m = parseFloat(m), p("number")) : isNaN(Date.parse(m)) ? p("string") : (m = m.replace(/\//g, "-"), p("date")) : p("number"), r2.length < f + 1 && r2.push([]), "number" != typeof m && "number" !== s3.guessType(m) && a) {
                let e4 = m;
                m = m.replace(a, "."), "number" !== s3.guessType(m) && (m = e4);
              }
              r2[f][t3] = m, m = "", ++f, ++c;
            };
            if (e3.trim().length && "#" !== e3.trim()[0]) {
              for (; u < e3.length; u++) {
                if (d(u), "#" === h && !/^#[A-F\d]{3,3}|[A-F\d]{6,6}/i.test(e3.substring(u))) {
                  g();
                  return;
                }
                if ('"' === h) for (d(++u); u < e3.length && '"' !== h; ) m += h, d(++u);
                else h === l ? g() : m += h;
              }
              g();
            }
          }
          guessDelimiter(e3) {
            let t3 = 0, s3 = 0, r2, o = { ",": 0, ";": 0, "	": 0 }, n = e3.length;
            for (let r3 = 0; r3 < n; r3++) {
              let n2 = false, i, l, a, u = "";
              if (r3 > 13) break;
              let h = e3[r3];
              for (let e4 = 0; e4 < h.length && (i = h[e4], l = h[e4 + 1], a = h[e4 - 1], "#" !== i); e4++) {
                if ('"' === i) {
                  if (n2) {
                    if ('"' !== a && '"' !== l) {
                      for (; " " === l && e4 < h.length; ) l = h[++e4];
                      void 0 !== o[l] && o[l]++, n2 = false;
                    }
                  } else n2 = true;
                } else void 0 !== o[i] ? (isNaN(Date.parse(u = u.trim())) ? (isNaN(Number(u)) || !isFinite(Number(u))) && o[i]++ : o[i]++, u = "") : u += i;
                "," === i && s3++, "." === i && t3++;
              }
            }
            return o[";"] > o[","] ? r2 = ";" : (o[","], o[";"], r2 = ","), t3 > s3 ? this.guessedDecimalPoint = "." : this.guessedDecimalPoint = ",", r2;
          }
          getTable() {
            return e2.getTableFromColumns(this.columns, this.headers);
          }
        }
        return r.defaultOptions = { ...e2.defaultOptions, lineDelimiter: "\n" }, r;
      }), s(t, "Data/Connectors/CSVConnector.js", [t["Data/Converters/CSVConverter.js"], t["Data/Connectors/DataConnector.js"], t["Core/Utilities.js"]], function(e2, t2, s2) {
        let { merge: r } = s2;
        class o extends t2 {
          constructor(t3) {
            let s3 = r(o.defaultOptions, t3);
            super(s3), this.converter = new e2(s3), this.options = s3, s3.enablePolling && this.startPolling(1e3 * Math.max(s3.dataRefreshRate || 0, 1));
          }
          load(e3) {
            let t3 = this, s3 = t3.converter, r2 = t3.table, { csv: o2, csvURL: n, dataModifier: i } = t3.options;
            return t3.emit({ type: "load", csv: o2, detail: e3, table: r2 }), Promise.resolve(n ? fetch(n).then((e4) => e4.text()) : o2 || "").then((e4) => (e4 && (r2.deleteColumns(), s3.parse({ csv: e4 }), r2.setColumns(s3.getTable().getColumns())), t3.setModifierOptions(i).then(() => e4))).then((s4) => (t3.emit({ type: "afterLoad", csv: s4, detail: e3, table: r2 }), t3)).catch((s4) => {
              throw t3.emit({ type: "loadError", detail: e3, error: s4, table: r2 }), s4;
            });
          }
        }
        return o.defaultOptions = { csv: "", csvURL: "", enablePolling: false, dataRefreshRate: 1, firstRowAsNames: true }, t2.registerType("CSV", o), o;
      }), s(t, "Data/Converters/JSONConverter.js", [t["Data/Converters/DataConverter.js"], t["Data/DataTable.js"], t["Core/Utilities.js"]], function(e2, t2, s2) {
        let { error: r, isArray: o, merge: n, objectEach: i } = s2;
        class l extends e2 {
          constructor(e3) {
            let s3 = n(l.defaultOptions, e3);
            super(s3), this.columns = [], this.headers = [], this.options = s3, this.table = new t2();
          }
          parse(e3, t3) {
            let { beforeParse: s3, orientation: l2, firstRowAsNames: a, columnNames: u } = e3 = n(this.options, e3), h = e3.data;
            if (h) {
              if (this.columns = [], this.emit({ type: "parse", columns: this.columns, detail: t3, headers: this.headers }), s3 && (h = s3(h)), h = h.slice(), "columns" === l2) for (let e4 = 0, t4 = h.length; e4 < t4; e4++) {
                let t5 = h[e4];
                if (!(t5 instanceof Array)) return;
                this.headers instanceof Array ? (a ? this.headers.push(`${t5.shift()}`) : u && u instanceof Array && this.headers.push(u[e4]), this.table.setColumn(this.headers[e4] || e4.toString(), t5)) : r("JSONConverter: Invalid `columnNames` option.", false);
              }
              else if ("rows" === l2) {
                a ? this.headers = h.shift() : u && (this.headers = u);
                for (let e4 = 0, t4 = h.length; e4 < t4; e4++) {
                  let t5 = h[e4];
                  if (o(t5)) for (let e5 = 0, s4 = t5.length; e5 < s4; e5++) this.columns.length < e5 + 1 && this.columns.push([]), this.columns[e5].push(t5[e5]), this.headers instanceof Array ? this.table.setColumn(this.headers[e5] || e5.toString(), this.columns[e5]) : r("JSONConverter: Invalid `columnNames` option.", false);
                  else {
                    let s4 = this.headers;
                    if (s4 && !(s4 instanceof Array)) {
                      let e5 = {};
                      i(s4, (s5, r2) => {
                        e5[r2] = s5.reduce((e6, t6) => e6[t6], t5);
                      }), t5 = e5;
                    }
                    this.table.setRows([t5], e4);
                  }
                }
              }
              this.emit({ type: "afterParse", columns: this.columns, detail: t3, headers: this.headers });
            }
          }
          getTable() {
            return this.table;
          }
        }
        return l.defaultOptions = { ...e2.defaultOptions, data: [], orientation: "rows" }, l;
      }), s(t, "Data/Connectors/JSONConnector.js", [t["Data/Connectors/DataConnector.js"], t["Core/Utilities.js"], t["Data/Converters/JSONConverter.js"]], function(e2, t2, s2) {
        let { merge: r } = t2;
        class o extends e2 {
          constructor(e3) {
            let t3 = r(o.defaultOptions, e3);
            super(t3), this.converter = new s2(t3), this.options = t3, t3.enablePolling && this.startPolling(1e3 * Math.max(t3.dataRefreshRate || 0, 1));
          }
          load(e3) {
            let t3 = this, s3 = t3.converter, r2 = t3.table, { data: o2, dataUrl: n, dataModifier: i } = t3.options;
            return t3.emit({ type: "load", data: o2, detail: e3, table: r2 }), Promise.resolve(n ? fetch(n).then((e4) => e4.json()) : o2 || []).then((e4) => (e4 && (r2.deleteColumns(), s3.parse({ data: e4 }), r2.setColumns(s3.getTable().getColumns()), r2.setRowKeysColumn(e4.length)), t3.setModifierOptions(i).then(() => e4))).then((s4) => (t3.emit({ type: "afterLoad", data: s4, detail: e3, table: r2 }), t3)).catch((s4) => {
              throw t3.emit({ type: "loadError", detail: e3, error: s4, table: r2 }), s4;
            });
          }
        }
        return o.defaultOptions = { data: [], enablePolling: false, dataRefreshRate: 0, firstRowAsNames: true, orientation: "rows" }, e2.registerType("JSON", o), o;
      }), s(t, "Data/Converters/GoogleSheetsConverter.js", [t["Data/Converters/DataConverter.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { merge: s2, uniqueKey: r } = t2;
        class o extends e2 {
          constructor(e3) {
            let t3 = s2(o.defaultOptions, e3);
            super(t3), this.columns = [], this.header = [], this.options = t3;
          }
          parse(e3, t3) {
            var _a;
            let o2;
            let n = s2(this.options, e3), i = (((_a = n.json) == null ? void 0 : _a.values) || []).map((e4) => e4.slice());
            if (0 === i.length) return false;
            this.header = [], this.columns = [], this.emit({ type: "parse", columns: this.columns, detail: t3, headers: this.header });
            let { beforeParse: l, json: a } = n;
            l && a && (i = l(a.values)), this.columns = i;
            for (let e4 = 0, t4 = i.length; e4 < t4; e4++) {
              o2 = i[e4], this.header[e4] = n.firstRowAsNames ? `${o2.shift()}` : r();
              for (let t5 = 0, s3 = o2.length; t5 < s3; ++t5) if (o2[t5] && "string" == typeof o2[t5]) {
                let s4 = this.asGuessedType(o2[t5]);
                s4 instanceof Date && (s4 = s4.getTime()), this.columns[e4][t5] = s4;
              }
            }
            this.emit({ type: "afterParse", columns: this.columns, detail: t3, headers: this.header });
          }
          getTable() {
            return e2.getTableFromColumns(this.columns, this.header);
          }
        }
        return o.defaultOptions = { ...e2.defaultOptions }, o;
      }), s(t, "Data/Connectors/GoogleSheetsConnector.js", [t["Data/Connectors/DataConnector.js"], t["Data/Converters/GoogleSheetsConverter.js"], t["Core/Utilities.js"]], function(e2, t2, s2) {
        let { merge: r, pick: o } = s2;
        class n extends e2 {
          constructor(e3) {
            let s3 = r(n.defaultOptions, e3);
            super(s3), this.converter = new t2(s3), this.options = s3;
          }
          load(e3) {
            let t3 = this, s3 = t3.converter, r2 = t3.table, { dataModifier: o2, dataRefreshRate: i, enablePolling: l, firstRowAsNames: a, googleAPIKey: u, googleSpreadsheetKey: h } = t3.options, m = n.buildFetchURL(u, h, t3.options);
            return t3.emit({ type: "load", detail: e3, table: r2, url: m }), fetch(m).then((e4) => e4.json()).then((e4) => {
              if ("object" == typeof e4 && e4 && "object" == typeof e4.error && e4.error && "number" == typeof e4.error.code && "string" == typeof e4.error.message && "string" == typeof e4.error.status) throw Error(e4.error.message);
              return s3.parse({ firstRowAsNames: a, json: e4 }), r2.deleteColumns(), r2.setColumns(s3.getTable().getColumns()), t3.setModifierOptions(o2);
            }).then(() => (t3.emit({ type: "afterLoad", detail: e3, table: r2, url: m }), l && setTimeout(() => t3.load(), 1e3 * Math.max(i || 0, 1)), t3)).catch((s4) => {
              throw t3.emit({ type: "loadError", detail: e3, error: s4, table: r2 }), s4;
            });
          }
        }
        return n.defaultOptions = { googleAPIKey: "", googleSpreadsheetKey: "", worksheet: 1, enablePolling: false, dataRefreshRate: 2, firstRowAsNames: true }, function(e3) {
          let t3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
          function s3(e4 = {}) {
            let { endColumn: r2, endRow: n2, googleSpreadsheetRange: i, startColumn: l, startRow: a } = e4;
            return i || (t3[l || 0] || "A") + (Math.max(a || 0, 0) + 1) + ":" + (t3[o(r2, 25)] || "Z") + (n2 ? Math.max(n2, 0) : "Z");
          }
          e3.buildFetchURL = function(e4, t4, r2 = {}) {
            return `https://sheets.googleapis.com/v4/spreadsheets/${t4}/values/` + (r2.onlyColumnNames ? "A1:Z1" : s3(r2)) + "?alt=json" + (r2.onlyColumnNames ? "" : "&dateTimeRenderOption=FORMATTED_STRING&majorDimension=COLUMNS&valueRenderOption=UNFORMATTED_VALUE") + `&prettyPrint=false&key=${e4}`;
          }, e3.buildQueryRange = s3;
        }(n || (n = {})), e2.registerType("GoogleSheets", n), n;
      }), s(t, "Data/Converters/HTMLTableConverter.js", [t["Data/Converters/DataConverter.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { merge: s2 } = t2;
        class r extends e2 {
          constructor(e3) {
            let t3 = s2(r.defaultOptions, e3);
            super(t3), this.columns = [], this.headers = [], this.options = t3, t3.tableElement && (this.tableElement = t3.tableElement, this.tableElementID = t3.tableElement.id);
          }
          export(e3, t3 = this.options) {
            let s3 = false !== t3.firstRowAsNames, r2 = t3.useMultiLevelHeaders, o = e3.getSortedColumns(t3.usePresentationOrder), n = Object.keys(o), i = [], l = n.length, a = [], u = "";
            if (s3) {
              let e4 = [];
              if (r2) {
                for (let t4 of n) {
                  let s4 = (o[t4].shift() || "").toString();
                  e4.push(s4);
                }
                u = this.getTableHeaderHTML(n, e4, t3);
              } else u = this.getTableHeaderHTML(void 0, n, t3);
            }
            for (let e4 = 0; e4 < l; e4++) {
              let t4 = o[n[e4]], s4 = t4.length;
              for (let r3 = 0; r3 < s4; r3++) {
                let s5 = t4[r3];
                a[r3] || (a[r3] = []), "string" == typeof s5 || "number" == typeof s5 || void 0 === s5 || (s5 = (s5 || "").toString()), a[r3][e4] = this.getCellHTMLFromValue(e4 ? "td" : "th", null, e4 ? "" : 'scope="row"', s5), e4 === l - 1 && i.push("<tr>" + a[r3].join("") + "</tr>");
              }
            }
            let h = "";
            return t3.tableCaption && (h = '<caption class="highcharts-table-caption">' + t3.tableCaption + "</caption>"), "<table>" + h + u + "<tbody>" + i.join("") + "</tbody></table>";
          }
          getCellHTMLFromValue(e3, t3, s3, r2, o) {
            let n = r2, i = "text" + (t3 ? " " + t3 : "");
            return "number" == typeof n ? (n = n.toString(), "," === o && (n = n.replace(".", o)), i = "number") : r2 || (n = "", i = "empty"), "<" + e3 + (s3 ? " " + s3 : "") + ' class="' + i + '">' + n + "</" + e3 + ">";
          }
          getTableHeaderHTML(e3 = [], t3 = [], s3 = this.options) {
            let { useMultiLevelHeaders: r2, useRowspanHeaders: o } = s3, n = "<thead>", i = 0, l = t3 && t3.length, a, u = 0, h;
            if (r2 && e3 && t3 && !function(e4, t4) {
              let s4 = e4.length;
              if (t4.length !== s4) return false;
              for (; --s4; ) if (e4[s4] !== t4[s4]) return false;
              return true;
            }(e3, t3)) {
              for (n += "<tr>"; i < l; ++i) (a = e3[i]) === e3[i + 1] ? ++u : u ? (n += this.getCellHTMLFromValue("th", "highcharts-table-topheading", 'scope="col" colspan="' + (u + 1) + '"', a), u = 0) : (a === t3[i] ? o ? (h = 2, delete t3[i]) : (h = 1, t3[i] = "") : h = 1, n += this.getCellHTMLFromValue("th", "highcharts-table-topheading", 'scope="col"' + (h > 1 ? ' valign="top" rowspan="' + h + '"' : ""), a));
              n += "</tr>";
            }
            if (t3) {
              for (n += "<tr>", i = 0, l = t3.length; i < l; ++i) void 0 !== t3[i] && (n += this.getCellHTMLFromValue("th", null, 'scope="col"', t3[i]));
              n += "</tr>";
            }
            return n + "</thead>";
          }
          parse(e3, t3) {
            let r2 = [], o = [], n = s2(this.options, e3), { endRow: i, startColumn: l, endColumn: a, firstRowAsNames: u } = n, h = n.tableElement || this.tableElement;
            if (!(h instanceof HTMLElement)) {
              this.emit({ type: "parseError", columns: r2, detail: t3, headers: o, error: "Not a valid HTML Table" });
              return;
            }
            this.tableElement = h, this.tableElementID = h.id, this.emit({ type: "parse", columns: this.columns, detail: t3, headers: this.headers });
            let m = h.getElementsByTagName("tr"), c = m.length, f = 0, d, { startRow: p } = n;
            if (u && c) {
              let e4 = m[0].children, t4 = e4.length;
              for (let s3 = l; s3 < t4 && !(s3 > a); s3++) ("TD" === (d = e4[s3]).tagName || "TH" === d.tagName) && o.push(d.innerHTML);
              p++;
            }
            for (; f < c; ) {
              if (f >= p && f <= i) {
                let e4 = m[f].children, t4 = e4.length, s3 = 0;
                for (; s3 < t4; ) {
                  let t5 = s3 - l, o2 = r2[t5];
                  if (("TD" === (d = e4[s3]).tagName || "TH" === d.tagName) && s3 >= l && s3 <= a) {
                    r2[t5] || (r2[t5] = []);
                    let e5 = this.asGuessedType(d.innerHTML);
                    e5 instanceof Date && (e5 = e5.getTime()), r2[t5][f - p] = e5;
                    let s4 = 1;
                    for (; f - p >= s4 && void 0 === o2[f - p - s4]; ) o2[f - p - s4] = null, s4++;
                  }
                  s3++;
                }
              }
              f++;
            }
            this.columns = r2, this.headers = o, this.emit({ type: "afterParse", columns: r2, detail: t3, headers: o });
          }
          getTable() {
            return e2.getTableFromColumns(this.columns, this.headers);
          }
        }
        return r.defaultOptions = { ...e2.defaultOptions, useRowspanHeaders: true, useMultiLevelHeaders: true }, r;
      }), s(t, "Data/Connectors/HTMLTableConnector.js", [t["Data/Connectors/DataConnector.js"], t["Core/Globals.js"], t["Data/Converters/HTMLTableConverter.js"], t["Core/Utilities.js"]], function(e2, t2, s2, r) {
        let { win: o } = t2, { merge: n } = r;
        class i extends e2 {
          constructor(e3) {
            let t3 = n(i.defaultOptions, e3);
            super(t3), this.converter = new s2(t3), this.options = t3;
          }
          load(e3) {
            let t3;
            let s3 = this, r2 = s3.converter, i2 = s3.table, { dataModifier: l, table: a } = s3.options;
            if (s3.emit({ type: "load", detail: e3, table: i2, tableElement: s3.tableElement }), "string" == typeof a ? (s3.tableID = a, t3 = o.document.getElementById(a)) : (t3 = a, s3.tableID = t3.id), s3.tableElement = t3 || void 0, !s3.tableElement) {
              let t4 = "HTML table not provided, or element with ID not found";
              return s3.emit({ type: "loadError", detail: e3, error: t4, table: i2 }), Promise.reject(Error(t4));
            }
            return r2.parse(n({ tableElement: s3.tableElement }, s3.options), e3), i2.deleteColumns(), i2.setColumns(r2.getTable().getColumns()), s3.setModifierOptions(l).then(() => (s3.emit({ type: "afterLoad", detail: e3, table: i2, tableElement: s3.tableElement }), s3));
          }
        }
        return i.defaultOptions = { table: "" }, e2.registerType("HTMLTable", i), i;
      }), s(t, "Data/Modifiers/ChainModifier.js", [t["Data/Modifiers/DataModifier.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { merge: s2 } = t2;
        class r extends e2 {
          constructor(t3, ...o) {
            super(), this.chain = o, this.options = s2(r.defaultOptions, t3);
            let n = this.options.chain || [];
            for (let t4 = 0, s3 = n.length, r2, i; t4 < s3; ++t4) (r2 = n[t4]).type && (i = e2.types[r2.type]) && o.push(new i(r2));
          }
          add(e3, t3) {
            this.emit({ type: "addModifier", detail: t3, modifier: e3 }), this.chain.push(e3), this.emit({ type: "addModifier", detail: t3, modifier: e3 });
          }
          clear(e3) {
            this.emit({ type: "clearChain", detail: e3 }), this.chain.length = 0, this.emit({ type: "afterClearChain", detail: e3 });
          }
          modify(e3, t3) {
            let s3 = this.options.reverse ? this.chain.slice().reverse() : this.chain.slice();
            e3.modified === e3 && (e3.modified = e3.clone(false, t3));
            let r2 = Promise.resolve(e3);
            for (let e4 = 0, o = s3.length; e4 < o; ++e4) {
              let o2 = s3[e4];
              r2 = r2.then((e5) => o2.modify(e5.modified, t3));
            }
            return (r2 = r2.then((t4) => (e3.modified.deleteColumns(), e3.modified.setColumns(t4.modified.getColumns()), e3))).catch((s4) => {
              throw this.emit({ type: "error", detail: t3, table: e3 }), s4;
            });
          }
          modifyCell(e3, t3, s3, r2, o) {
            let n = this.options.reverse ? this.chain.reverse() : this.chain;
            if (n.length) {
              let i = e3.clone();
              for (let e4 = 0, l = n.length; e4 < l; ++e4) n[e4].modifyCell(i, t3, s3, r2, o), i = i.modified;
              e3.modified = i;
            }
            return e3;
          }
          modifyColumns(e3, t3, s3, r2) {
            let o = this.options.reverse ? this.chain.reverse() : this.chain.slice();
            if (o.length) {
              let n = e3.clone();
              for (let e4 = 0, i = o.length; e4 < i; ++e4) o[e4].modifyColumns(n, t3, s3, r2), n = n.modified;
              e3.modified = n;
            }
            return e3;
          }
          modifyRows(e3, t3, s3, r2) {
            let o = this.options.reverse ? this.chain.reverse() : this.chain.slice();
            if (o.length) {
              let n = e3.clone();
              for (let e4 = 0, i = o.length; e4 < i; ++e4) o[e4].modifyRows(n, t3, s3, r2), n = n.modified;
              e3.modified = n;
            }
            return e3;
          }
          modifyTable(e3, t3) {
            this.emit({ type: "modify", detail: t3, table: e3 });
            let s3 = this.options.reverse ? this.chain.reverse() : this.chain.slice(), r2 = e3.modified;
            for (let e4 = 0, o = s3.length; e4 < o; ++e4) r2 = s3[e4].modifyTable(r2, t3).modified;
            return e3.modified = r2, this.emit({ type: "afterModify", detail: t3, table: e3 }), e3;
          }
          remove(e3, t3) {
            let s3 = this.chain;
            this.emit({ type: "removeModifier", detail: t3, modifier: e3 }), s3.splice(s3.indexOf(e3), 1), this.emit({ type: "afterRemoveModifier", detail: t3, modifier: e3 });
          }
        }
        return r.defaultOptions = { type: "Chain" }, e2.registerType("Chain", r), r;
      }), s(t, "Data/Modifiers/InvertModifier.js", [t["Data/Modifiers/DataModifier.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { merge: s2 } = t2;
        class r extends e2 {
          constructor(e3) {
            super(), this.options = s2(r.defaultOptions, e3);
          }
          modifyCell(e3, t3, s3, r2, o) {
            let n = e3.modified, i = n.getRowIndexBy("columnNames", t3);
            return void 0 === i ? n.setColumns(this.modifyTable(e3.clone()).getColumns(), void 0, o) : n.setCell(`${s3}`, i, r2, o), e3;
          }
          modifyColumns(e3, t3, s3, r2) {
            let o = e3.modified, n = o.getColumn("columnNames") || [], i = e3.getColumnNames(), l = e3.getRowCount() !== n.length;
            if (!l) {
              for (let e4 = 0, t4 = i.length; e4 < t4; ++e4) if (i[e4] !== n[e4]) {
                l = true;
                break;
              }
            }
            if (l) return this.modifyTable(e3, r2);
            i = Object.keys(t3);
            for (let e4 = 0, n2 = i.length, l2, a, u; e4 < n2; ++e4) {
              l2 = t3[a = i[e4]], u = o.getRowIndexBy("columnNames", a) || o.getRowCount();
              for (let e5 = 0, t4 = s3, n3 = l2.length; e5 < n3; ++e5, ++t4) o.setCell(`${t4}`, u, l2[e5], r2);
            }
            return e3;
          }
          modifyRows(e3, t3, s3, r2) {
            let o = e3.getColumnNames(), n = e3.modified, i = n.getColumn("columnNames") || [], l = e3.getRowCount() !== i.length;
            if (!l) {
              for (let e4 = 0, t4 = o.length; e4 < t4; ++e4) if (o[e4] !== i[e4]) {
                l = true;
                break;
              }
            }
            if (l) return this.modifyTable(e3, r2);
            for (let e4 = 0, i2 = s3, l2 = t3.length, a; e4 < l2; ++e4, ++i2) if ((a = t3[e4]) instanceof Array) n.setColumn(`${i2}`, a);
            else for (let e5 = 0, t4 = o.length; e5 < t4; ++e5) n.setCell(`${i2}`, e5, a[o[e5]], r2);
            return e3;
          }
          modifyTable(e3, t3) {
            this.emit({ type: "modify", detail: t3, table: e3 });
            let s3 = e3.modified;
            if (e3.hasColumns(["columnNames"])) {
              let t4 = ((e3.deleteColumns(["columnNames"]) || {}).columnNames || []).map((e4) => `${e4}`), r2 = {};
              for (let s4 = 0, o = e3.getRowCount(), n; s4 < o; ++s4) (n = e3.getRow(s4)) && (r2[t4[s4]] = n);
              s3.deleteColumns(), s3.setColumns(r2);
            } else {
              let t4 = {};
              for (let s4 = 0, r2 = e3.getRowCount(), o; s4 < r2; ++s4) (o = e3.getRow(s4)) && (t4[`${s4}`] = o);
              t4.columnNames = e3.getColumnNames(), s3.deleteColumns(), s3.setColumns(t4);
            }
            return this.emit({ type: "afterModify", detail: t3, table: e3 }), e3;
          }
        }
        return r.defaultOptions = { type: "Invert" }, e2.registerType("Invert", r), r;
      }), s(t, "Data/Modifiers/MathModifier.js", [t["Data/Modifiers/DataModifier.js"], t["Data/Formula/FormulaParser.js"], t["Data/Formula/FormulaProcessor.js"]], function(e2, t2, s2) {
        class r extends e2 {
          constructor(e3) {
            super(), this.options = { ...r.defaultOptions, ...e3 };
          }
          modifyTable(e3, s3) {
            this.emit({ type: "modify", detail: s3, table: e3 });
            let r2 = this.options.alternativeSeparators, o = this.options.formulaColumns || e3.getColumnNames(), n = e3.modified;
            for (let t3 = 0, s4 = o.length, r3; t3 < s4; ++t3) r3 = o[t3], o.indexOf(r3) >= 0 && n.setColumn(r3, this.processColumn(e3, r3));
            let i = this.options.columnFormulas || [];
            for (let s4 = 0, o2 = i.length, l, a; s4 < o2; ++s4) l = i[s4], a = t2.parseFormula(l.formula, r2), n.setColumn(l.column, this.processColumnFormula(a, e3, l.rowStart, l.rowEnd));
            return this.emit({ type: "afterModify", detail: s3, table: e3 }), e3;
          }
          processColumn(e3, r2, o = 0) {
            let n = this.options.alternativeSeparators, i = (e3.getColumn(r2, true) || []).slice(o > 0 ? o : 0);
            for (let r3 = 0, o2 = i.length, l = [], a; r3 < o2; ++r3) if ("string" == typeof (a = i[r3]) && "=" === a[0]) try {
              l = "" === a ? l : t2.parseFormula(a.substring(1), n), i[r3] = s2.processFormula(l, e3);
            } catch {
              i[r3] = NaN;
            }
            return i;
          }
          processColumnFormula(e3, t3, r2 = 0, o = t3.getRowCount()) {
            r2 = r2 >= 0 ? r2 : 0, o = o >= 0 ? o : t3.getRowCount() + o;
            let n = [], i = t3.modified;
            for (let t4 = 0, l = o - r2; t4 < l; ++t4) try {
              n[t4] = s2.processFormula(e3, i);
            } catch {
              n[t4] = NaN;
            } finally {
              e3 = s2.translateReferences(e3, 0, 1);
            }
            return n;
          }
        }
        return r.defaultOptions = { type: "Math", alternativeSeparators: false }, e2.registerType("Math", r), r;
      }), s(t, "Data/Modifiers/RangeModifier.js", [t["Data/Modifiers/DataModifier.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { merge: s2 } = t2;
        class r extends e2 {
          constructor(e3) {
            super(), this.options = s2(r.defaultOptions, e3);
          }
          modifyTable(e3, t3) {
            this.emit({ type: "modify", detail: t3, table: e3 });
            let { additive: s3, ranges: r2, strict: o } = this.options;
            if (r2.length) {
              let t4 = e3.modified, n = e3.getColumns(), i = [];
              for (let l = 0, a = r2.length, u, h; l < a; ++l) if (u = r2[l], !o || typeof u.minValue == typeof u.maxValue) {
                l > 0 && !s3 && (t4.deleteRows(), t4.setRows(i), n = t4.getColumns(), i = []), h = n[u.column] || [];
                for (let r3 = 0, n2 = h.length, l2, a2; r3 < n2; ++r3) {
                  switch (typeof (l2 = h[r3])) {
                    default:
                      continue;
                    case "boolean":
                    case "number":
                    case "string":
                  }
                  (!o || typeof l2 == typeof u.minValue) && l2 >= u.minValue && l2 <= u.maxValue && (a2 = s3 ? e3.getRow(r3) : t4.getRow(r3)) && i.push(a2);
                }
              }
              t4.deleteRows(), t4.setRows(i);
            }
            return this.emit({ type: "afterModify", detail: t3, table: e3 }), e3;
          }
        }
        return r.defaultOptions = { type: "Range", ranges: [] }, e2.registerType("Range", r), r;
      }), s(t, "Data/Modifiers/SortModifier.js", [t["Data/Modifiers/DataModifier.js"], t["Data/DataTable.js"], t["Core/Utilities.js"]], function(e2, t2, s2) {
        let { merge: r } = s2;
        class o extends e2 {
          static ascending(e3, t3) {
            return (e3 || 0) < (t3 || 0) ? -1 : (e3 || 0) > (t3 || 0) ? 1 : 0;
          }
          static descending(e3, t3) {
            return (t3 || 0) < (e3 || 0) ? -1 : (t3 || 0) > (e3 || 0) ? 1 : 0;
          }
          constructor(e3) {
            super(), this.options = r(o.defaultOptions, e3);
          }
          getRowReferences(e3) {
            let t3 = e3.getRows(), s3 = [];
            for (let e4 = 0, r2 = t3.length; e4 < r2; ++e4) s3.push({ index: e4, row: t3[e4] });
            return s3;
          }
          modifyCell(e3, s3, r2, o2, n) {
            let { orderByColumn: i, orderInColumn: l } = this.options;
            return s3 === i && (l ? (e3.modified.setCell(s3, r2, o2), e3.modified.setColumn(l, this.modifyTable(new t2({ columns: e3.getColumns([i, l]) })).modified.getColumn(l))) : this.modifyTable(e3, n)), e3;
          }
          modifyColumns(e3, s3, r2, o2) {
            let { orderByColumn: n, orderInColumn: i } = this.options, l = Object.keys(s3);
            return l.indexOf(n) > -1 && (i && s3[l[0]].length ? (e3.modified.setColumns(s3, r2), e3.modified.setColumn(i, this.modifyTable(new t2({ columns: e3.getColumns([n, i]) })).modified.getColumn(i))) : this.modifyTable(e3, o2)), e3;
          }
          modifyRows(e3, s3, r2, o2) {
            let { orderByColumn: n, orderInColumn: i } = this.options;
            return i && s3.length ? (e3.modified.setRows(s3, r2), e3.modified.setColumn(i, this.modifyTable(new t2({ columns: e3.getColumns([n, i]) })).modified.getColumn(i))) : this.modifyTable(e3, o2), e3;
          }
          modifyTable(e3, t3) {
            this.emit({ type: "modify", detail: t3, table: e3 });
            let s3 = e3.getColumnNames(), r2 = e3.getRowCount(), n = this.getRowReferences(e3), { direction: i, orderByColumn: l, orderInColumn: a } = this.options, u = "asc" === i ? o.ascending : o.descending, h = s3.indexOf(l), m = e3.modified;
            if (-1 !== h && n.sort((e4, t4) => u(e4.row[h], t4.row[h])), a) {
              let e4 = [];
              for (let t4 = 0; t4 < r2; ++t4) e4[n[t4].index] = t4;
              m.setColumns({ [a]: e4 });
            } else {
              let e4 = [];
              for (let t4 = 0; t4 < r2; ++t4) e4.push(n[t4].row);
              m.setRows(e4, 0);
            }
            return this.emit({ type: "afterModify", detail: t3, table: e3 }), e3;
          }
        }
        return o.defaultOptions = { type: "Sort", direction: "desc", orderByColumn: "y" }, e2.registerType("Sort", o), o;
      }), s(t, "masters/modules/data-tools.src.js", [t["Core/Globals.js"], t["Data/Connectors/DataConnector.js"], t["Data/Converters/DataConverter.js"], t["Data/DataCursor.js"], t["Data/Modifiers/DataModifier.js"], t["Data/DataPool.js"], t["Data/DataTable.js"], t["Data/Formula/Formula.js"]], function(e2, t2, s2, r, o, n, i, l) {
        return e2.DataConnector = e2.DataConnector || t2, e2.DataConverter = e2.DataConverter || s2, e2.DataCursor = e2.DataCursor || r, e2.DataModifier = e2.DataModifier || o, e2.DataPool = e2.DataPool || n, e2.DataTable = e2.DataTable || i, e2.Formula = e2.Formula || l, e2;
      });
    });
  }
});
export default require_data_tools();
//# sourceMappingURL=highcharts_modules_data-tools__js.js.map
